Index: madwifi/net80211/ieee80211_ioctl.h
===================================================================
--- madwifi.orig/net80211/ieee80211_ioctl.h	2007-09-17 17:42:10.000000000 +0200
+++ madwifi/net80211/ieee80211_ioctl.h	2007-09-17 17:42:01.000000000 +0200
@@ -604,6 +604,7 @@
 	IEEE80211_PARAM_DROPUNENC_EAPOL		= 60,	/* drop unencrypted eapol frames */
  	IEEE80211_PARAM_SHPREAMBLE		= 61,	/* Short Preamble */
 	IEEE80211_PARAM_DUMPREGS		= 62,   /* Pretty printed dump of Atheros hardware registers */
+	IEEE80211_PARAM_BATMAN			= 63,   /* enable/disable batman meshing mode */
 };
 
 #define	SIOCG80211STATS			(SIOCDEVPRIVATE+2)
@@ -633,7 +634,8 @@
 	IEEE80211_APPIE_FRAME_PROBE_RESP	= 2,
 	IEEE80211_APPIE_FRAME_ASSOC_REQ		= 3,
 	IEEE80211_APPIE_FRAME_ASSOC_RESP	= 4,
-	IEEE80211_APPIE_NUM_OF_FRAME		= 5
+	IEEE80211_APPIE_BATMAN			= 5,
+	IEEE80211_APPIE_NUM_OF_FRAME		= 6
 };
 
 struct ieee80211req_getset_appiebuf {
Index: madwifi/net80211/ieee80211_wireless.c
===================================================================
--- madwifi.orig/net80211/ieee80211_wireless.c	2007-09-08 00:45:19.000000000 +0200
+++ madwifi/net80211/ieee80211_wireless.c	2007-09-17 23:13:14.000000000 +0200
@@ -213,7 +213,7 @@
 
 			/*
 			 * Set key contents.  This interface only supports WEP.
-			 * Indicate intended key index.			 
+			 * Indicate intended key index.
 			 */
 			k->wk_keyix = kix;
 			if (ieee80211_crypto_newkey(vap, IEEE80211_CIPHER_WEP,
@@ -495,10 +495,10 @@
 	if (vap->iv_opmode == IEEE80211_M_WDS)
 		IEEE80211_ADDR_COPY(vap->wds_mac, &ap_addr->sa_data);
 
-	/* 
-	 * zero address corresponds to 'iwconfig ath0 ap off', which means 
+	/*
+	 * zero address corresponds to 'iwconfig ath0 ap off', which means
 	 * enable automatic choice of AP without actually forcing a
-	 * reassociation.  
+	 * reassociation.
 	 *
 	 * broadcast address corresponds to 'iwconfig ath0 ap any', which
 	 * means scan for the current best AP.
@@ -756,8 +756,8 @@
 			ic->ic_set_channel(ic);
 		}
 	} else if(vap->iv_opmode == IEEE80211_M_HOSTAP) {
-		/* Need to use channel switch announcement on beacon if we are 
-		 * up and running.  We use ic_set_channel directly if we are 
+		/* Need to use channel switch announcement on beacon if we are
+		 * up and running.  We use ic_set_channel directly if we are
 		 * "running" but not "up".  Otherwise, iv_des_chan will take
 		 * effect when we are transitioned to RUN state later. */
 		if(IS_UP(vap->iv_dev)) {
@@ -960,9 +960,9 @@
 		}
 	}
 
-	/* Atheros' RSSI value is SNR: 0 -> 60 for old chipsets. Range 
-	 * for newer chipsets is unknown. This value is arbitarily chosen 
-	 * to give an indication that full rate will be available and to be 
+	/* Atheros' RSSI value is SNR: 0 -> 60 for old chipsets. Range
+	 * for newer chipsets is unknown. This value is arbitarily chosen
+	 * to give an indication that full rate will be available and to be
 	 * a practicable maximum. */
 	range->max_qual.qual  = 70;
 #if WIRELESS_EXT >= 19
@@ -1148,7 +1148,7 @@
 		IEEE80211_DPRINTF(vap, IEEE80211_MSG_DEBUG,
 			"%s: disabled iw_spy threshold\n", __func__);
 	} else {
-		/* We are passed a signal level/strength - calculate 
+		/* We are passed a signal level/strength - calculate
 		 * corresponding RSSI values */
 		/* XXX: We should use current noise value. */
 		vap->iv_spy.thr_low = threshold.low.level + ATH_DEFAULT_NOISE;
@@ -1236,7 +1236,7 @@
 	struct ieee80211vap *vap = dev->priv;
 	struct ieee80211com *ic = vap->iv_ic;
 
-	/* XXX: These values, flags, and caps do not seem to be used elsewhere 
+	/* XXX: These values, flags, and caps do not seem to be used elsewhere
 	 * at all? */
 
 	if ((ic->ic_caps & IEEE80211_C_PMGT) == 0)
@@ -2308,7 +2308,7 @@
 	case IEEE80211_PARAM_WMM:
 		if (ic->ic_caps & IEEE80211_C_WME){
 			retv = ENETRESET;	/* Renegotiate for capabilities */
-			
+
 			if (value) {
 				/* All TKIP keys need resetting to use software MIC.
 				 * They aren't, so this is disabled.
@@ -2321,11 +2321,11 @@
 				}
 			} else {
 				vap->iv_flags &= ~IEEE80211_F_WME;
-				
+
 				{
 					struct ieee80211vap *v = NULL;
 					int all = 1;
-					
+
 					TAILQ_FOREACH(v, &vap->iv_ic->ic_vaps, iv_next) {
 						if (v->iv_flags & IEEE80211_F_WME) {
 							all = 0;
@@ -2386,10 +2386,10 @@
 		if (vap->iv_ath_cap != caps) {
 			if ((vap->iv_ath_cap ^ caps) & IEEE80211_ATHC_TURBOP) {
 				/* no turbo and XR at the same time */
-				if ((caps & IEEE80211_ATHC_TURBOP) && 
+				if ((caps & IEEE80211_ATHC_TURBOP) &&
 						(caps & IEEE80211_ATHC_XR))
 					return -EINVAL;
-				if (ieee80211_set_turbo(dev, 
+				if (ieee80211_set_turbo(dev,
 						(caps & IEEE80211_ATHC_TURBOP)))
 					return -EINVAL;
 				ieee80211_scan_flush(ic);
@@ -2627,6 +2627,37 @@
 		ieee80211_dump_registers(dev, info, w, extra);
 		break;
 #endif /* #ifdef ATH_REVERSE_ENGINEERING */
+	case IEEE80211_PARAM_BATMAN:
+		if (batman_ops_net80211 == NULL) {
+			retv = EOPNOTSUPP;
+			break;
+		}
+
+		if ((vap->iv_opmode != IEEE80211_M_HOSTAP) && (vap->iv_opmode != IEEE80211_M_IBSS)) {
+			retv = EMEDIUMTYPE;
+			break;
+		}
+
+		if (value) {
+			u_int8_t batman_buff[sizeof(struct ieee80211req_getset_appiebuf) + sizeof(struct ieee80211_ie) + 255];
+			struct ieee80211_ie *ie = (struct ieee80211_ie *)(batman_buff + sizeof(struct ieee80211req_getset_appiebuf));
+
+			retv = - batman_ops_net80211->attach(vap->iv_dev, ie->info, &ie->len);
+
+			if (retv == 0) {
+				((struct ieee80211req_getset_appiebuf *)batman_buff)->app_frmtype = IEEE80211_APPIE_BATMAN;
+				((struct ieee80211req_getset_appiebuf *)batman_buff)->app_buflen = sizeof(struct ieee80211_ie) + ie->len;
+				ie->id = IEEE80211_ELEMID_BATMAN;
+
+				add_app_ie(IEEE80211_APPIE_BATMAN, vap, (struct ieee80211req_getset_appiebuf *)batman_buff);
+			}
+		} else {
+			retv = - batman_ops_net80211->detach(vap->iv_dev);
+
+			if (retv == 0)
+				remove_app_ie(IEEE80211_APPIE_BATMAN, vap);
+		}
+		break;
 	default:
 		retv = EOPNOTSUPP;
 		break;
@@ -2639,7 +2670,7 @@
 		vap->iv_xrvap->iv_ath_cap &= IEEE80211_ATHC_XR;
 	}
 	/*
-	 * do not reset the xr vap , which is automatically 
+	 * do not reset the xr vap , which is automatically
 	 * reset by the state machine now.
 	 */
 	if (!vap->iv_xrvap || (vap->iv_xrvap && !(vap->iv_flags & IEEE80211_F_XR))) {
@@ -3032,7 +3063,7 @@
 }
 
 /* the following functions are used by the set/get appiebuf functions */
-static int
+int
 add_app_ie(unsigned int frame_type_index, struct ieee80211vap *vap,
 	struct ieee80211req_getset_appiebuf *iebuf)
 {
@@ -3054,7 +3085,7 @@
 	return 0;
 }
 
-static int
+int
 remove_app_ie(unsigned int frame_type_index, struct ieee80211vap *vap)
 {
 	struct ieee80211_app_ie *app_ie = &vap->app_ie[frame_type_index];
@@ -3320,7 +3351,7 @@
 
 	kix = dk->idk_keyix;
 
-	/* XXX: This cast can be removed when struct ieee80211req_del_key is 
+	/* XXX: This cast can be removed when struct ieee80211req_del_key is
 	 * fixed. */
 	if (dk->idk_keyix == (u_int8_t) IEEE80211_KEYIX_NONE) {
 		struct ieee80211_node *ni;
@@ -3520,7 +3551,7 @@
 	if (IEEE80211_ADDR_NULL(vap->wds_mac))
 		return 0;
 
-	/* Compare suplied MAC address with WDS MAC of this interface 
+	/* Compare suplied MAC address with WDS MAC of this interface
 	 * remove when mac address is known
 	 */
 	if (memcmp(vap->wds_mac, sa->sa_data, IEEE80211_ADDR_LEN) == 0) {
@@ -4454,14 +4485,14 @@
 	return ieee80211_ioctl_setparam(dev, NULL, NULL, (char*)args);
 }
 
-/* 
+/*
  * If this function is invoked it means someone is using the wireless extensions
  * API instead of the private madwifi ioctls.  That's fine.  We translate their
- * request into the format used by the private ioctls.  Note that the 
- * iw_request_info and iw_param structures are not the same ones as the 
+ * request into the format used by the private ioctls.  Note that the
+ * iw_request_info and iw_param structures are not the same ones as the
  * private ioctl handler expects.  Luckily, the private ioctl handler doesn't
- * do anything with those at the moment.  We pass NULL for those, because in 
- * case someone does modify the ioctl handler to use those values, a null 
+ * do anything with those at the moment.  We pass NULL for those, because in
+ * case someone does modify the ioctl handler to use those values, a null
  * pointer will be easier to debug than other bad behavior.
  */
 static int
@@ -4840,7 +4871,7 @@
 
 	/* TODO This memcmp for the broadcast address seems hackish, but
 	 * mimics what wpa supplicant was doing.  The wpa supplicant comments
-	 * make it sound like they were having trouble with 
+	 * make it sound like they were having trouble with
 	 * IEEE80211_IOCTL_SETKEY and static WEP keys.  It might be worth
 	 * figuring out what their trouble was so the rest of this function
 	 * can be implemented in terms of ieee80211_ioctl_setkey */
@@ -5266,6 +5297,8 @@
 	  0, IW_PRIV_TYPE_APPIEBUF, "getiebuf" },
 	{ IEEE80211_IOCTL_FILTERFRAME,
 	  IW_PRIV_TYPE_FILTER , 0, "setfilter" },
+	{ IEEE80211_PARAM_BATMAN,
+	  IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "batman" },
 
 #ifdef ATH_REVERSE_ENGINEERING
 	/*
Index: madwifi/net80211/ieee80211_linux.c
===================================================================
--- madwifi.orig/net80211/ieee80211_linux.c	2007-09-08 00:45:19.000000000 +0200
+++ madwifi/net80211/ieee80211_linux.c	2007-09-13 18:21:41.000000000 +0200
@@ -956,6 +956,12 @@
 }
 EXPORT_SYMBOL(ether_sprintf);		/* XXX */
 
+/*
+ * Hooks for batman functions
+ */
+struct batman_ops_net80211 *batman_ops_net80211 = NULL;
+EXPORT_SYMBOL(batman_ops_net80211);
+
 /* Function to handle the device event notifications.
  * If the event is a NETDEV_CHANGENAME, and is for an interface
  * we are taking care of, then we want to remove its existing
Index: madwifi/net80211/ieee80211_linux.h
===================================================================
--- madwifi.orig/net80211/ieee80211_linux.h	2007-09-08 00:45:19.000000000 +0200
+++ madwifi/net80211/ieee80211_linux.h	2007-09-17 20:37:13.000000000 +0200
@@ -31,6 +31,7 @@
 
 #include <linux/wireless.h>
 #include <linux/fs.h>
+#include "ieee80211_batman.h"
 
 /*
  * Compatibility definition of statistics flags
@@ -55,15 +56,15 @@
 #endif
 
 /*
- * The RSSI values reported in the TX/RX descriptors in the driver are the SNR 
+ * The RSSI values reported in the TX/RX descriptors in the driver are the SNR
  * expressed in dBm. Thus 'rssi' is signal level above the noise floor in dBm.
  *
- * Noise is measured in dBm and is negative unless there is an unimaginable 
- * level of RF noise. 
+ * Noise is measured in dBm and is negative unless there is an unimaginable
+ * level of RF noise.
  *
  * The signal level is noise + rssi.
  *
- * Note that the iw_quality values are 1 byte, and can be signed, unsigned or 
+ * Note that the iw_quality values are 1 byte, and can be signed, unsigned or
  * negative depending on context.
  *
  */
@@ -113,14 +114,14 @@
 
 /* Locking */
 /* NB: beware, spin_is_locked() is not usefully defined for !(DEBUG || SMP)
- * because spinlocks do not exist in this configuration. Instead IRQs 
+ * because spinlocks do not exist in this configuration. Instead IRQs
  * or pre-emption are simply disabled, as this is all that is needed.
  */
 
 /*
  * Beacon handler locking definitions.
- * Beacon locking 
- * UAPSD locking 
+ * Beacon locking
+ * UAPSD locking
  */
 typedef spinlock_t ieee80211com_lock_t;
 #define	IEEE80211_LOCK_INIT(_ic, _name)				\
Index: madwifi/net80211/ieee80211_batman.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ madwifi/net80211/ieee80211_batman.h	2007-09-17 23:11:02.000000000 +0200
@@ -0,0 +1,41 @@
+/*-
+ * Copyright (c) 2007 Marek Lindner
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id: ieee80211_batman.h 2634 2007-08-04 02:06:48Z mentor $
+ */
+
+
+
+#include <linux/netdevice.h>	/* netdevice */
+
+
+
+struct batman_ops_net80211 {
+	int (*attach) (struct net_device *dev, u_int8_t *ie_buff, u_int8_t *ie_buff_len);
+	int (*detach) (struct net_device *dev);
+};
+
+extern struct batman_ops_net80211 *batman_ops_net80211;
Index: madwifi/net80211/ieee80211.h
===================================================================
--- madwifi.orig/net80211/ieee80211.h	2007-09-17 17:06:16.000000000 +0200
+++ madwifi/net80211/ieee80211.h	2007-09-17 17:06:58.000000000 +0200
@@ -352,7 +352,7 @@
 	CTRY_ZIMBABWE             = 716      /* Zimbabwe */
 };
 
-/* 
+/*
  * Generic information element
  */
 struct ieee80211_ie {
@@ -361,7 +361,7 @@
 	u_int8_t info[0];
 } __packed;
 
-/* 
+/*
  * Country information element.
  */
 #define IEEE80211_COUNTRY_MAX_TRIPLETS (83)
@@ -700,6 +700,7 @@
 	IEEE80211_ELEMID_TPC		= 150,
 	IEEE80211_ELEMID_CCKM		= 156,
 	IEEE80211_ELEMID_VENDOR		= 221,	/* vendor private */
+	IEEE80211_ELEMID_BATMAN		= 233,	/* batman */
 };
 
 #define IEEE80211_CHANSWITCHANN_BYTES 5
@@ -919,7 +920,7 @@
 
 #define	IEEE80211_AID(b)	((b) &~ 0xc000)
 
-/* 
+/*
  * RTS frame length parameters.  The default is specified in
  * the 802.11 spec.  The max may be wrong for jumbo frames.
  */
@@ -927,7 +928,7 @@
 #define	IEEE80211_RTS_MIN		1
 #define	IEEE80211_RTS_MAX		2346
 
-/* 
+/*
  * Regulatory extension identifier for country IE.
  */
 #define IEEE80211_REG_EXT_ID		201
Index: madwifi/net80211/ieee80211_var.h
===================================================================
--- madwifi.orig/net80211/ieee80211_var.h	2007-09-17 23:40:21.000000000 +0200
+++ madwifi/net80211/ieee80211_var.h	2007-09-17 23:40:33.000000000 +0200
@@ -592,6 +592,9 @@
 void ieee80211_build_countryie(struct ieee80211com *);
 int ieee80211_media_setup(struct ieee80211com *, struct ifmedia *, u_int32_t,
 	ifm_change_cb_t, ifm_stat_cb_t);
+int add_app_ie(unsigned int frame_type_index, struct ieee80211vap *vap,
+	       struct ieee80211req_getset_appiebuf *iebuf);
+int remove_app_ie(unsigned int frame_type_index, struct ieee80211vap *vap);
 
 /* Key update synchronization methods.  XXX should not be visible. */
 static __inline void
